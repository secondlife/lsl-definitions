"""Generator for SLua documentation files for Luau LSP, like this one:
https://github.com/MaximumADHD/Roblox-Client-Tracker/blob/roblox/api-docs/en-us.json
"""

from __future__ import annotations

import json

from lsl_definitions.generators.base import register
from lsl_definitions.lsl import LSLDefinitions
from lsl_definitions.slua import (
    SLuaDefinitions,
    SLuaFunction,
)
from lsl_definitions.utils import (
    escape_python,
    remove_nones,
)

GLOBALS_PREFIX = "@sl-slua/global/"


def doc_function(func: SLuaFunction, method=False) -> dict:
    entry = remove_nones(
        documentation=escape_python(func.comment or f"{func.name} function"),
    )
    return {f"{GLOBALS_PREFIX}{func.name}": entry}


@register("slua_lsp_docs")
def gen_slua_lsp_docs(definitions: LSLDefinitions, slua_definitions: SLuaDefinitions) -> str:
    """Generate SLua standard library for Luau LSP docs.json"""
    # slua_definitions.generate_ll_modules(definitions)
    #     classes = {c.name: c for c in slua_definitions.baseClasses + slua_definitions.classes}
    #     type_aliases = {a.name: a for a in slua_definitions.typeAliases}

    docs = {}

    #     file = io.StringIO()
    #     file.write("""# Second Life SLua (Server Lua) standard library definition file for selene.
    # # This file is auto-generated by https://github.com/secondlife/lsl-definitions.
    # """)
    #     selene = {
    #         "base": "luau",
    #         "name": "Second Life SLua language support",
    #         "lua_versions": ["luau", "lua51"],
    #         "globals": {},
    #         "structs": {},
    #     }

    #     def selene_type(type_str: str, default="any") -> str | dict | None:
    #         if type_str.endswith("?"):
    #             type_str = type_str[:-1]
    #         type_map = {
    #             "boolean": "bool",
    #             "boolean | number": "bool",
    #             "number": "number",
    #             "string": "string",
    #             "buffer": {"display": "buffer"},
    #             "uuid": {"display": "uuid"},
    #             "vector": {"display": "vector"},
    #             "quaternion": {"display": "quaternion"},
    #             "list": "table",
    #             "thread": {"display": "thread"},
    #         }
    #         if type_str in type_map:
    #             return type_map[type_str]
    #         if type_str in type_aliases:
    #             return type_aliases[type_str].selene_type
    #         if type_str.startswith("..."):
    #             return "..."
    #         if type_str.startswith("{") and type_str.endswith("}"):
    #             return "table"
    #         if "|" in type_str:
    #             return default
    #         if "->" in type_str:
    #             return "function"
    #         return default

    #     def selene_property(prop: SLuaProperty) -> dict:
    #         if prop.slua_removed:
    #             return remove_nones(removed=True, description=prop.comment or None)
    #         elif prop.type in classes:
    #             return remove_nones(struct=prop.type, description=prop.comment or None)
    #         else:
    #             return remove_nones(
    #                 property=prop.modifiable,
    #                 type=selene_type(prop.type, default=None),
    #                 description=prop.comment or None,
    #             )

    #     def selene_param(param: SLuaParameter) -> dict:
    #         optional = param.type.endswith("?") if param.optional is None else param.optional
    #         return remove_nones(
    #             type=param.selene_type or selene_type(param.type),
    #             required=None if not optional and param.optional is None else not optional,
    #             observes=param.observes,
    #         )

    #     def selene_class(class_: SLuaClassDeclaration) -> dict:
    #         fields = {}
    #         for method in class_.methods:
    #             fields[method.name] = selene_function(method, method=True)
    #         for prop in class_.properties:
    #             fields[prop.name] = selene_property(prop)
    #         return fields

    #     def selene_module(module: SLuaModule) -> dict:
    #         globals = {}
    #         if module.callable:
    #             globals[module.name] = selene_function(module.callable)
    #         globals.update(
    #             {
    #                 f"{module.name}.{const.name}": selene_property(const)
    #                 # for func in sorted(self.functions, key=lambda x: x.name)
    #                 for const in module.constants
    #                 if not const.private
    #             }
    #         )
    #         globals.update(
    #             {
    #                 f"{module.name}.{func.name}": selene_function(func)
    #                 # for func in sorted(self.functions, key=lambda x: x.name)
    #                 for func in module.functions
    #                 if not func.private
    #             }
    #         )
    #         return globals

    #     # Duplicate quaternion module as rotation. The callable aspect of quaternion
    #     # prevents us from being able to de-duplicate this with structs.
    #     modules = {m.name: m for m in slua_definitions.modules}
    #     modules["rotation"] = SLuaModule(
    #         name="rotation",
    #         comment=modules["quaternion"].comment,
    #         callable=modules["quaternion"].callable,
    #         constants=modules["quaternion"].constants,
    #         functions=modules["quaternion"].functions,
    #     )

    #     for const in slua_definitions.globalVariables:
    #         if not const.private and const.name != "rotation":
    #             selene["globals"][const.name] = selene_property(const)
    #     for const in sorted(slua_definitions.globalConstants, key=lambda x: x.name):
    #         if not const.private and not const.slua_removed:
    #             selene["globals"][const.name] = selene_property(const)
    # for func in slua_definitions.builtinFunctions:
    #     selene["globals"][func.name] = func.to_selene_dict()
    for func in slua_definitions.globalFunctions:
        docs.update(doc_function(func))
    #     for module in sorted(modules.values(), key=lambda x: x.name):
    #         if module.name not in {"ll", "llcompat"}:
    #             selene["globals"].update(selene_module(module))
    #     selene["globals"].update(selene_module(modules["ll"]))
    #     selene["globals"].update(selene_module(modules["llcompat"]))
    #     for class_ in classes.values():
    #         selene["structs"][class_.name] = selene_class(class_)

    #     # Fix up LLEvents argument types
    #     event_names = [m for m in slua_definitions.typeAliases if m.name == "LLEventName"][
    #         0
    #     ].selene_type
    #     for method_name in ["on", "once", "off", "listeners"]:
    #         selene["structs"]["LLEvents"][method_name]["args"][0]["type"] = event_names

    return json.dumps(docs, indent=4)
