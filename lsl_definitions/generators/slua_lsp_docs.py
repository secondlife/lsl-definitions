"""Generator for SLua documentation files for Luau LSP, like this one:
https://github.com/MaximumADHD/Roblox-Client-Tracker/blob/roblox/api-docs/en-us.json
"""

from __future__ import annotations

import dataclasses
import json

from lsl_definitions.generators.base import register
from lsl_definitions.lsl import LSLDefinitions
from lsl_definitions.slua import (
    SLuaDefinitions,
    SLuaFunction,
    SLuaModule,
    SLuaProperty,
)
from lsl_definitions.utils import (
    remove_nones,
)

GLOBALS_PREFIX = "@sl-slua/global/"


def htmlize(text: str) -> str:
    text = text.replace("\\n", "\n").strip()
    text = text.replace("\n", "<br>")
    text = text.replace("    ", "&nbsp;&nbsp;")
    text = text.replace("\t", "&nbsp;")
    return text


def doc_url(module: str | None, func: str | None) -> str | None:
    # TODO: None of these links actually exist
    if module == "ll" and func is not None:
        return f"https://create.secondlife.com/script/slua-reference/functions/ll{func.lower()}/"
    if func in {"toquaternion", "tovector"}:
        return f"https://create.secondlife.com/script/slua-reference/{func}/"
    if module in {"uuid", "vector", "quaternion", "bit32", "lljson", "llbase64"}:
        if func is None:
            return f"https://create.secondlife.com/script/slua-reference/{module}/"
    return None


@dataclasses.dataclass
class DocBuilder:
    docs: dict = dataclasses.field(default_factory=dict)

    def add_function(self, func: SLuaFunction, module: str | None = None, method=False):
        module_prefix = f"{module}." if module else ""
        entry = remove_nones(
            documentation=htmlize(func.comment or f"{func.name} function"),
            learn_more_link=doc_url(module, func.name),
        )
        self.docs[f"{GLOBALS_PREFIX}{module_prefix}{func.name}"] = entry

    def add_constant(self, const: SLuaProperty, module: str | None = None):
        module_prefix = f"{module}." if module else ""
        value = f"Value: {const.value}" if const.value is not None else ""
        comment = htmlize(const.comment)
        documentation = value + "<br>" + comment if comment and value else value + comment
        entry = remove_nones(
            documentation=documentation,
            learn_more_link=doc_url(module, const.name),
        )
        self.docs[f"{GLOBALS_PREFIX}{module_prefix}{const.name}"] = entry

    def add_module(self, module: SLuaModule) -> None:
        if module.callable:
            self.add_function(module.callable)
        else:
            self.docs[f"{GLOBALS_PREFIX}{module.name}"] = remove_nones(
                documentation=htmlize(module.comment),
                learn_more_link=doc_url(module.name, None),
            )
        # for const in sorted(self.constants, key=lambda x: x.name)
        for const in module.constants:
            if not const.private:
                self.add_constant(const, module=module.name)
        # for func in sorted(self.functions, key=lambda x: x.name)
        for func in module.functions:
            if not func.private:
                self.add_function(func, module=module.name)


@register("slua_lsp_docs")
def gen_slua_lsp_docs(definitions: LSLDefinitions, slua_definitions: SLuaDefinitions) -> str:
    """Generate SLua standard library for Luau LSP docs.json"""
    slua_definitions.generate_ll_modules(definitions)
    #     classes = {c.name: c for c in slua_definitions.baseClasses + slua_definitions.classes}
    #     type_aliases = {a.name: a for a in slua_definitions.typeAliases}

    builder = DocBuilder()

    #     file = io.StringIO()
    #     file.write("""# Second Life SLua (Server Lua) standard library definition file for selene.
    # # This file is auto-generated by https://github.com/secondlife/lsl-definitions.
    # """)
    #     selene = {
    #         "base": "luau",
    #         "name": "Second Life SLua language support",
    #         "lua_versions": ["luau", "lua51"],
    #         "globals": {},
    #         "structs": {},
    #     }

    #     def selene_type(type_str: str, default="any") -> str | dict | None:
    #         if type_str.endswith("?"):
    #             type_str = type_str[:-1]
    #         type_map = {
    #             "boolean": "bool",
    #             "boolean | number": "bool",
    #             "number": "number",
    #             "string": "string",
    #             "buffer": {"display": "buffer"},
    #             "uuid": {"display": "uuid"},
    #             "vector": {"display": "vector"},
    #             "quaternion": {"display": "quaternion"},
    #             "list": "table",
    #             "thread": {"display": "thread"},
    #         }
    #         if type_str in type_map:
    #             return type_map[type_str]
    #         if type_str in type_aliases:
    #             return type_aliases[type_str].selene_type
    #         if type_str.startswith("..."):
    #             return "..."
    #         if type_str.startswith("{") and type_str.endswith("}"):
    #             return "table"
    #         if "|" in type_str:
    #             return default
    #         if "->" in type_str:
    #             return "function"
    #         return default

    #     def selene_property(prop: SLuaProperty) -> dict:
    #         if prop.slua_removed:
    #             return remove_nones(removed=True, description=prop.comment or None)
    #         elif prop.type in classes:
    #             return remove_nones(struct=prop.type, description=prop.comment or None)
    #         else:
    #             return remove_nones(
    #                 property=prop.modifiable,
    #                 type=selene_type(prop.type, default=None),
    #                 description=prop.comment or None,
    #             )

    #     def selene_param(param: SLuaParameter) -> dict:
    #         optional = param.type.endswith("?") if param.optional is None else param.optional
    #         return remove_nones(
    #             type=param.selene_type or selene_type(param.type),
    #             required=None if not optional and param.optional is None else not optional,
    #             observes=param.observes,
    #         )

    #     def selene_class(class_: SLuaClassDeclaration) -> dict:
    #         fields = {}
    #         for method in class_.methods:
    #             fields[method.name] = selene_function(method, method=True)
    #         for prop in class_.properties:
    #             fields[prop.name] = selene_property(prop)
    #         return fields

    # Duplicate quaternion module as rotation. The callable aspect of quaternion
    # prevents us from being able to de-duplicate this with structs.
    modules = {m.name: m for m in slua_definitions.modules}
    modules["rotation"] = SLuaModule(
        name="rotation",
        comment=modules["quaternion"].comment,
        callable=modules["quaternion"].callable,
        constants=modules["quaternion"].constants,
        functions=modules["quaternion"].functions,
    )

    #     for const in slua_definitions.globalVariables:
    #         if not const.private and const.name != "rotation":
    #             selene["globals"][const.name] = selene_property(const)
    # for func in slua_definitions.builtinFunctions:
    #     selene["globals"][func.name] = func.to_selene_dict()
    for func in slua_definitions.globalFunctions:
        builder.add_function(func)
    for module in sorted(modules.values(), key=lambda x: x.name):
        if module.name not in {"ll", "llcompat"}:
            builder.add_module(module)
    builder.add_module(modules["ll"])
    builder.add_module(modules["llcompat"])
    for const in sorted(slua_definitions.globalConstants, key=lambda x: x.name):
        if not const.private and not const.slua_removed:
            builder.add_constant(const)
    #     for class_ in classes.values():
    #         selene["structs"][class_.name] = selene_class(class_)

    #     # Fix up LLEvents argument types
    #     event_names = [m for m in slua_definitions.typeAliases if m.name == "LLEventName"][
    #         0
    #     ].selene_type
    #     for method_name in ["on", "once", "off", "listeners"]:
    #         selene["structs"]["LLEvents"][method_name]["args"][0]["type"] = event_names

    return json.dumps(builder.docs, indent=4)
