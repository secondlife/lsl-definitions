"""Generators for viewer syntax/keywords XML files."""

from __future__ import annotations

import llsd

from lsl_definitions.generators.base import register
from lsl_definitions.lsl import LSLDefinitions
from lsl_definitions.slua import SLuaDefinitions


@register("syntax")
def dump_syntax(definitions: LSLDefinitions, *, pretty: bool = False) -> bytes:
    """Generate LSL syntax XML for viewer"""
    header_comment = b"""<!-- LSL (Linden Scripting Language) keywords file for Second Life Viewer.
This file is auto-generated by https://github.com/secondlife/lsl-definitions. -->"""
    syntax = {
        "controls": definitions.controls.copy(),
        "types": definitions.types.copy(),
        "constants": {},
        "events": {},
        "functions": {},
        "llsd-lsl-syntax-version": 2,
    }
    for event in sorted(definitions.events.values(), key=lambda x: x.name):
        if event.private:
            continue
        syntax["events"][event.name] = event.to_dict()

    for func in sorted(definitions.functions.values(), key=lambda x: x.name):
        if func.private:
            continue
        syntax["functions"][func.name] = func.to_dict()

    for const in sorted(definitions.constants.values(), key=lambda x: x.name):
        if const.private:
            continue
        syntax["constants"][const.name] = const.to_dict()

    # This one's a little weird because it's not a "real" constant, but it's expected to be in the
    # constants section even though it has no value or type. It allows default to have a tooltip
    # and a distinct color.
    syntax["constants"]["default"] = {
        "tooltip": "All scripts must have a default state, which is the first state entered when the script starts.\n"
        "If another state is defined before the default state, the compiler will report a syntax error."
    }

    if pretty:
        output = llsd.LLSDXMLPrettyFormatter(indent_atom=b"   ").format(syntax)
        header_comment = b"\n" + header_comment
    else:
        output = llsd.format_xml(syntax)
    start_offset = output.find(b"?>") + 2
    output = output[:start_offset] + header_comment + output[start_offset:]
    return output


@register("slua_syntax")
def dump_slua_syntax(
    definitions: LSLDefinitions,
    slua_definitions: SLuaDefinitions,
    *,
    pretty: bool = False,
) -> bytes:
    """Generate SLua syntax XML for viewer"""
    ll_module = next(m for m in slua_definitions.modules if m.name == "ll")
    header_comment = b"""<!-- SLua (Server Lua) keywords file for Second Life Viewer.
This file is auto-generated by https://github.com/secondlife/lsl-definitions. -->"""
    syntax = {
        "controls": slua_definitions.controls.copy(),
        "types": slua_definitions.builtinTypes.copy(),
        "constants": {},
        "events": {},
        "functions": {},
        "llsd-lsl-syntax-version": 2,
    }

    # types
    for class_ in sorted(slua_definitions.baseClasses, key=lambda x: x.name):
        syntax["types"][class_.name] = class_.to_keywords_dict()
    for alias in sorted(slua_definitions.typeAliases, key=lambda x: x.name):
        if alias.export:
            syntax["types"][alias.name] = alias.to_keywords_dict()
    for class_ in sorted(slua_definitions.classes, key=lambda x: x.name):
        syntax["types"][class_.name] = class_.to_keywords_dict()

    # events
    for event in sorted(definitions.events.values(), key=lambda x: x.name):
        if event.slua_removed:
            continue
        syntax["events"][event.name] = event.to_slua_dict(slua_definitions)

    # functions
    for func in slua_definitions.builtinFunctions:
        syntax["functions"][func.name] = func.to_keywords_dict()
    for func in sorted(slua_definitions.globalFunctions, key=lambda x: x.name):
        syntax["functions"][func.name] = func.to_keywords_dict()
    for module in sorted(slua_definitions.modules, key=lambda x: x.name):
        if module.name not in {"ll", "llcompat"}:
            syntax["functions"].update(module.to_keywords_functions_dict())
    syntax["functions"].update(ll_module.to_keywords_functions_dict())
    for func in sorted(definitions.functions.values(), key=lambda x: x.name):
        if not func.private:
            syntax["functions"][func.compute_slua_name()] = func.to_slua_dict(slua_definitions)

    # constants
    for const in slua_definitions.builtinConstants:
        syntax["constants"][const.name] = const.to_keywords_dict()
    for module in sorted(slua_definitions.modules, key=lambda x: x.name):
        syntax["constants"].update(module.to_keywords_constants_dict())
    for const in sorted(definitions.constants.values(), key=lambda x: x.name):
        if not const.private and not const.slua_removed:
            syntax["constants"][const.name] = const.to_slua_dict(slua_definitions)

    if pretty:
        output = llsd.LLSDXMLPrettyFormatter(indent_atom=b"   ").format(syntax)
        header_comment = b"\n" + header_comment
    else:
        output = llsd.format_xml(syntax)
    start_offset = output.find(b"?>") + 2
    output = output[:start_offset] + header_comment + output[start_offset:]
    return output
