"""Generator for builtins.txt (LSLint-compatible format)."""

from __future__ import annotations

from lsl_definitions.generators.base import register
from lsl_definitions.lsl import LSLDefinitions, LSLType


@register("gen_builtins_txt")
def gen_builtins_txt(definitions: LSLDefinitions) -> str:
    """Generate builtins.txt for LSLint-compatible implementations"""
    # See https://github.com/Sei-Lisa/kwdb/blob/master/outputs/builtins.txt for an example
    builtins_str = "// Generated by gen_definitions.py\n"

    for func in sorted(definitions.functions.values(), key=lambda x: x.name):
        args_str = ", ".join(f"{x.type!s} {x.name}" for x in func.arguments)
        builtins_str += f"{func.ret_type!s} {func.name}( {args_str} )\n"

    for const in sorted(definitions.constants.values(), key=lambda x: x.name):
        builtins_str += f"const {const.type!s} {const.name} = "
        if const.type == LSLType.STRING:
            # We don't use C encoding semantics to escape values because LSL only knows
            # about a handful of basic escapes like `\n`.
            # Other values we want to output verbatim.
            lsl_val = const.value.replace("\\", "\\\\").replace("\n", "\\n")
            builtins_str += f'"{lsl_val}"'
        else:
            builtins_str += const.value
        builtins_str += "\n"

    for event in sorted(definitions.events.values(), key=lambda x: x.name):
        args_str = ", ".join(f"{x.type!s} {x.name}" for x in event.arguments)
        builtins_str += f"event {event.name}( {args_str} )\n"

    return builtins_str
