"""Generators for SLua typechecker definition files (Luau LSP and Selene)."""

from __future__ import annotations

import io

import yaml

from lsl_definitions.generators.base import register
from lsl_definitions.lsl import LSLDefinitions
from lsl_definitions.slua import (
    SLuaClassDeclaration,
    SLuaDefinitions,
    SLuaFunction,
    SLuaModule,
    SLuaParameter,
    SLuaProperty,
)
from lsl_definitions.utils import remove_nones


@register("slua_lsp_defs")
def gen_luau_lsp_defs(definitions: LSLDefinitions, slua_definitions: SLuaDefinitions) -> str:
    """Generate SLua definitions for Luau Language Server"""
    slua_definitions.generate_ll_modules(definitions)
    ll_module = [m for m in slua_definitions.modules if m.name == "ll"][0]
    llcompat_module = [m for m in slua_definitions.modules if m.name == "llcompat"][0]

    defs = io.StringIO()
    defs.write("""-- Second Life SLua (Server Lua) definitions file for luau-lsp.
-- This file is auto-generated by https://github.com/secondlife/lsl-definitions.

----------------------------------
---------- LSL LUAU DEFS ---------
----------------------------------

""")

    # 1. Luau builtins unneeded. Luau-lsp already know about these
    # 2. SLua base classes. These only depend on Luau builtins
    classes = slua_definitions.baseClasses + slua_definitions.classes
    classes.sort(key=lambda x: x.name)
    for class_ in (class_ for class_ in classes if class_.name[0].islower()):
        class_.write_luau_def(defs)
    defs.write("\n")
    for alias in slua_definitions.typeAliases:
        defs.write(alias.to_luau_def())
        defs.write("\n")
    defs.write("\n")

    # 3. SLua standard library. Depends on base classes
    for class_ in (class_ for class_ in classes if class_.name[0].isupper()):
        class_.write_luau_def(defs)
    defs.write("\n")
    for func in slua_definitions.globalFunctions:
        defs.write("declare ")
        func.write_luau_global_def(defs)
    for module in sorted(slua_definitions.modules, key=lambda x: x.name):
        if module.name in {"ll", "llcompat"}:
            continue
        module.write_luau_def(defs)
    for var in slua_definitions.globalVariables:
        defs.write("declare ")
        defs.write(var.to_luau_def())
        defs.write("\n")
    ll_module.write_luau_def(defs)
    llcompat_module.write_luau_def(defs)
    for const in sorted(slua_definitions.globalConstants, key=lambda x: x.name):
        if const.private:
            continue
        defs.write("declare ")
        defs.write(const.to_luau_def())
        defs.write("\n")

    return defs.getvalue()


@register("slua_selene")
def gen_selene_yml(definitions: LSLDefinitions, slua_definitions: SLuaDefinitions) -> str:
    """Generate SLua standard library for Selene linter"""
    slua_definitions.generate_ll_modules(definitions)
    classes = {c.name: c for c in slua_definitions.baseClasses + slua_definitions.classes}
    type_aliases = {a.name: a for a in slua_definitions.typeAliases}

    file = io.StringIO()
    file.write("""# Second Life SLua (Server Lua) standard library definition file for selene.
# This file is auto-generated by https://github.com/secondlife/lsl-definitions.
""")
    selene = {
        "base": "luau",
        "name": "Second Life SLua language support",
        "lua_versions": ["luau", "lua51"],
        "globals": {},
        "structs": {},
    }

    def selene_type(type_str: str, default="any") -> str | dict | None:
        if type_str.endswith("?"):
            type_str = type_str[:-1]
        type_map = {
            "boolean": "bool",
            "boolean | number": "bool",
            "number": "number",
            "string": "string",
            "buffer": {"display": "buffer"},
            "uuid": {"display": "uuid"},
            "vector": {"display": "vector"},
            "quaternion": {"display": "quaternion"},
            "list": "table",
            "thread": {"display": "thread"},
        }
        if type_str in type_map:
            return type_map[type_str]
        if type_str in type_aliases:
            return type_aliases[type_str].selene_type
        if type_str.startswith("..."):
            return "..."
        if type_str.startswith("{") and type_str.endswith("}"):
            return "table"
        if "|" in type_str:
            return default
        if "->" in type_str:
            return "function"
        return default

    def selene_property(prop: SLuaProperty) -> dict:
        if prop.slua_removed:
            return remove_nones(removed=True, description=prop.comment or None)
        elif prop.type in classes:
            return remove_nones(struct=prop.type, description=prop.comment or None)
        else:
            return remove_nones(
                property=prop.modifiable,
                type=selene_type(prop.type, default=None),
                description=prop.comment or None,
            )

    def selene_param(param: SLuaParameter) -> dict:
        optional = param.type.endswith("?") if param.optional is None else param.optional
        return remove_nones(
            type=param.selene_type or selene_type(param.type),
            required=None if not optional and param.optional is None else not optional,
            observes=param.observes,
        )

    def selene_function(func: SLuaFunction, method=False) -> dict:
        parameters = func.parameters[1:] if method else func.parameters
        return remove_nones(
            method=method or None,
            deprecated={"message": func.comment} if func.deprecated else None,
            args=[selene_param(a) for a in parameters],
            must_use=func.must_use or None,
            description=func.comment or None,
        )

    def selene_class(class_: SLuaClassDeclaration) -> dict:
        fields = {}
        for method in class_.methods:
            fields[method.name] = selene_function(method, method=True)
        for prop in class_.properties:
            fields[prop.name] = selene_property(prop)
        return fields

    def selene_module(module: SLuaModule) -> dict:
        globals = {}
        if module.callable:
            globals[module.name] = selene_function(module.callable)
        globals.update(
            {
                f"{module.name}.{const.name}": selene_property(const)
                # for func in sorted(self.functions, key=lambda x: x.name)
                for const in module.constants
                if not const.private
            }
        )
        globals.update(
            {
                f"{module.name}.{func.name}": selene_function(func)
                # for func in sorted(self.functions, key=lambda x: x.name)
                for func in module.functions
                if not func.private
            }
        )
        return globals

    # Duplicate quaternion module as rotation. The callable aspect of quaternion
    # prevents us from being able to de-duplicate this with structs.
    modules = {m.name: m for m in slua_definitions.modules}
    modules["rotation"] = SLuaModule(
        name="rotation",
        comment=modules["quaternion"].comment,
        callable=modules["quaternion"].callable,
        constants=modules["quaternion"].constants,
        functions=modules["quaternion"].functions,
    )

    for const in slua_definitions.globalVariables:
        if not const.private and const.name != "rotation":
            selene["globals"][const.name] = selene_property(const)
    for const in sorted(slua_definitions.globalConstants, key=lambda x: x.name):
        if not const.private and not const.slua_removed:
            selene["globals"][const.name] = selene_property(const)
    # for func in slua_definitions.builtinFunctions:
    #     selene["globals"][func.name] = func.to_selene_dict()
    for func in slua_definitions.globalFunctions:
        selene["globals"][func.name] = selene_function(func)
    for module in sorted(modules.values(), key=lambda x: x.name):
        if module.name not in {"ll", "llcompat"}:
            selene["globals"].update(selene_module(module))
    selene["globals"].update(selene_module(modules["ll"]))
    selene["globals"].update(selene_module(modules["llcompat"]))
    for class_ in classes.values():
        selene["structs"][class_.name] = selene_class(class_)

    # Fix up LLEvents argument types
    event_names = [m for m in slua_definitions.typeAliases if m.name == "LLEventName"][
        0
    ].selene_type
    for method_name in ["on", "once", "off", "listeners"]:
        selene["structs"]["LLEvents"][method_name]["args"][0]["type"] = event_names

    noalias_dumper = yaml.dumper.SafeDumper
    noalias_dumper.ignore_aliases = lambda self, data: True
    yaml.dump(selene, file, sort_keys=False, Dumper=noalias_dumper)
    return file.getvalue()
